<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Luci â€” Offline Realistic Chatbot</title>
<style>
  :root{
    --bg:#f2f5fb; --blue:#0b84ff; --gray:#e9e9ee; --muted:#6b7280;
  }
  html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;background:var(--bg);color:#111}
  header{background:white;padding:12px 16px;border-bottom:1px solid #e6e9f2;text-align:center;font-weight:600}
  .app{max-width:900px;margin:0 auto;height:100%;display:flex;flex-direction:column}
  #chat{flex:1;overflow:auto;padding:16px;display:flex;flex-direction:column;gap:8px;background:linear-gradient(180deg,transparent,transparent)}
  .msg{max-width:78%;display:flex;flex-direction:column}
  .msg.user{align-self:flex-end;align-items:flex-end}
  .msg.bot{align-self:flex-start;align-items:flex-start}
  .bubble{padding:10px 14px;border-radius:18px;line-height:1.35;font-size:15px;word-break:break-word;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
  .user .bubble{background:var(--blue);color:white;border-bottom-right-radius:6px}
  .bot .bubble{background:var(--gray);color:#111;border-bottom-left-radius:6px}
  .meta{font-size:11px;color:var(--muted);margin-top:6px}
  .composer{display:flex;padding:10px;border-top:1px solid #e6e9f2;background:white;gap:8px}
  .composer input{flex:1;padding:10px 12px;border-radius:18px;border:1px solid #d6dbe9;font-size:15px}
  .composer button{padding:10px 14px;border-radius:12px;border:0;background:var(--blue);color:white;font-weight:600}
  .controls{display:flex;gap:8px;padding:8px;background:#fff;border-top:1px solid #e6e9f2;align-items:center;justify-content:space-between}
  .controls .left{display:flex;gap:8px;align-items:center}
  .small{font-size:12px;color:var(--muted)}
  .typing .bubble{background:var(--gray);display:inline-block}
  .dots{width:30px;height:12px;display:inline-block;position:relative}
  .dots span{display:block;width:6px;height:6px;background:#8a8f98;border-radius:50%;position:absolute;bottom:0;animation:dots 1s infinite}
  .dots span:nth-child(2){left:10px;animation-delay:.15s}
  .dots span:nth-child(3){left:20px;animation-delay:.3s}
  @keyframes dots{0%{transform:translateY(0)}50%{transform:translateY(-5px)}100%{transform:translateY(0)}}
  .tag{background:#eef6ff;color:#0366d6;padding:6px 8px;border-radius:10px;font-size:12px}
  .panel{padding:12px}
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(12,20,40,0.35);display:flex;align-items:center;justify-content:center;z-index:999}
  .box{background:white;padding:16px;border-radius:12px;max-width:780px;max-height:80vh;overflow:auto;border:1px solid #e6e9f2}
  .row{display:flex;gap:8px;align-items:center}
  input[type="file"]{display:none}
</style>
</head>
<body>
<header>Luci â€” Offline Realistic Chatbot</header>
<div class="app" id="app">
  <div id="chat" aria-live="polite"></div>

  <div class="controls">
    <div class="left">
      <button id="clearBtn" class="small">Clear</button>
      <button id="exportBtn" class="small">Export convo</button>
      <button id="importBtn" class="small">Import convo</button>
      <label class="tag" id="sizeTag">Dataset: generating...</label>
    </div>
    <div>
      <span class="small">Memory:</span>
      <select id="memSelect" class="small">
        <option value="100">100 turns</option>
        <option value="250" selected>250 turns</option>
        <option value="500">500 turns</option>
        <option value="1000">1000 turns</option>
      </select>
      <button id="downloadHTML" class="small">Download full .html</button>
    </div>
  </div>

  <form id="talkForm" class="composer" autocomplete="off">
    <input id="userInput" type="text" placeholder="iMessage" autocomplete="off"/>
    <button type="submit">Send</button>
  </form>

  <div style="padding:8px;text-align:center" class="small">Fully offline â€” built to keep many realistic conversations.</div>
</div>

<!-- Import file input (hidden) -->
<input type="file" id="fileInput" accept="application/json"/>

<script>
(function(){
  // CONFIG
  const TARGET_DATASET_BYTES = 1.8 * 1024 * 1024; // ~1.8 MB dataset (adjustable in code)
  const DEFAULT_MEMORY = 250;

  // STATE
  let dataset = null;
  let memory = [];
  const storageKeys = {memory:'luci_memory_v2', conv:'luci_conv_v2', meta:'luci_meta_v2'};

  // SEEDS and templates for dataset generation
  const seeds = [
    "Hey, how's your day going?",
    "What are you up to right now?",
    "I tried a new coffee today and it was amazing.",
    "That sounds fun â€” tell me more!",
    "I'm feeling a little tired today.",
    "Tell me about your favorite song.",
    "I read an interesting article earlier.",
    "Do you want a quick joke?",
    "I can remember things you tell me for this chat.",
    "What's one small win you had today?",
    "Where are you chatting from?",
    "I like to keep things simple.",
    "That's a really thoughtful point.",
    "How does that make you feel?",
    "Would you like help making a plan?",
    "I enjoy hearing about new experiences.",
    "Nice â€” congratulations!",
    "Hmm, that's tricky.",
    "Be honest: do you prefer pizza or burgers?",
    "If you could travel anywhere, where would you go?",
    "What's a skill you wish you had?",
    "I love a good sunny afternoon walk.",
    "Have you tried a creative hobby lately?",
    "What movie has stuck with you recently?",
    "I sometimes journal to clear my head."
  ];

  const connectors = ["and", "but", "also", "so", "because", "therefore", "however", "meanwhile", "besides"];
  const endings = ["", ".", "!", " ðŸ™‚", " ðŸ˜„", " â€” tell me more.", " â€” that's interesting."];

  // UI elements
  const chatEl = document.getElementById('chat');
  const form = document.getElementById('talkForm');
  const input = document.getElementById('userInput');
  const clearBtn = document.getElementById('clearBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const fileInput = document.getElementById('fileInput');
  const sizeTag = document.getElementById('sizeTag');
  const memSelect = document.getElementById('memSelect');
  const downloadHTML = document.getElementById('downloadHTML');

  function log(msg){
    // append small invisible log in DOM if needed (kept minimal)
    console.debug('[Luci]', msg);
  }

  // Utility random
  function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // BUILD dataset programmatically until ~TARGET_DATASET_BYTES
  function buildLargeDataset(targetBytes){
    const out = [];
    // first, include all seeds
    seeds.forEach(s => out.push(s));
    let idx = 0;
    while(true){
      const a = seeds[idx % seeds.length];
      const b = seeds[(idx + 7) % seeds.length];
      const connector = connectors[idx % connectors.length];
      const ending = endings[idx % endings.length];
      // craft several variants to increase diversity
      out.push(`${a} ${connector} ${b}${ending}`);
      if(idx % 3 === 0) out.push(`${b} ${connector} ${a}${endings[(idx+2)%endings.length]}`);
      if(idx % 7 === 0) out.push(`${a} â€” I never expected that.`);
      if(idx % 11 === 0) out.push(`${b} â€” that's memorable.`);
      idx++;
      // check size occasionally
      if(idx % 50 === 0){
        const approx = new Blob([JSON.stringify(out)]).size;
        if(approx >= targetBytes) break;
        // safety
        if(out.length > 400000) break;
      }
    }
    return out;
  }

  // Build dataset on load (asynchronously-ish so UI can render)
  function startDatasetBuild(){
    sizeTag.innerText = 'Dataset: building...';
    return new Promise((resolve)=>{
      setTimeout(()=>{
        try{
          const ds = buildLargeDataset(TARGET_DATASET_BYTES);
          dataset = ds;
          const bytes = new Blob([JSON.stringify(dataset)]).size;
          sizeTag.innerText = `Dataset: ~${Math.round(bytes/1024)} KB`;
          resolve(dataset);
        }catch(e){
          console.error(e);
          sizeTag.innerText = 'Dataset: error';
          resolve([]);
        }
      }, 50);
    });
  }

  // Load memory and conversation from localStorage
  function loadState(){
    try{
      const mem = JSON.parse(localStorage.getItem(storageKeys.memory) || '[]');
      memory = Array.isArray(mem) ? mem : [];
      const conv = JSON.parse(localStorage.getItem(storageKeys.conv) || '[]');
      if(Array.isArray(conv) && conv.length) {
        conv.forEach(c=> appendMessage(c.text, c.sender, false));
      }
    }catch(e){
      memory = [];
    }
  }

  function saveMemory(){
    try{ localStorage.setItem(storageKeys.memory, JSON.stringify(memory)); }catch(e){}
  }
  function saveConvEntry(entry){
    try{
      const conv = JSON.parse(localStorage.getItem(storageKeys.conv) || '[]');
      conv.push(entry);
      localStorage.setItem(storageKeys.conv, JSON.stringify(conv));
    }catch(e){}
  }

  // Append message to UI
  function appendMessage(text, sender='bot', save=true){
    const d = document.createElement('div');
    d.className = 'msg ' + (sender==='user' ? 'user' : 'bot');
    const b = document.createElement('div');
    b.className = 'bubble';
    b.innerText = text;
    d.appendChild(b);
    // timestamp metadata (small)
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerText = (new Date()).toLocaleString();
    d.appendChild(meta);
    chatEl.appendChild(d);
    chatEl.scrollTop = chatEl.scrollHeight;
    if(save) {
      saveConvEntry({sender,text,time:new Date().toISOString()});
    }
  }

  // Typing indicator
  function showTyping(){
    const m = document.createElement('div');
    m.className = 'msg bot typing';
    const b = document.createElement('div');
    b.className = 'bubble';
    b.innerHTML = '<span class="dots"><span></span><span></span><span></span></span>';
    m.appendChild(b);
    chatEl.appendChild(m);
    chatEl.scrollTop = chatEl.scrollHeight;
    return m;
  }

  // Simple fuzzy scorer for dataset lines
  function fuzzyBestMatch(q){
    if(!dataset || dataset.length === 0) return null;
    const qWords = q.toLowerCase().split(/\W+/).filter(Boolean);
    let best = null;
    let bestScore = 0;
    // sample a subset to keep response time fast when dataset is large
    // sample 2000 random lines + first 500 lines (seeds)
    const sampleIndexes = new Set();
    for(let i=0;i<Math.min(500,dataset.length);i++) sampleIndexes.add(i);
    const SAMPLE_RANDOM = 1700;
    for(let i=0;i<SAMPLE_RANDOM;i++){
      sampleIndexes.add(Math.floor(Math.random()*dataset.length));
    }
    for(const i of sampleIndexes){
      const s = dataset[i].toLowerCase();
      let score = 0;
      for(const w of qWords) if(s.includes(w)) score++;
      if(score > bestScore){
        bestScore = score;
        best = dataset[i];
      }
    }
    return bestScore > 0 ? best : null;
  }

  // Markov-ish fallback: pick sentence containing a seed word or random otherwise
  function markovish(seed){
    const words = seed.toLowerCase().split(/\W+/).filter(Boolean);
    for(const w of words){
      const found = dataset.find(d => d.toLowerCase().includes(w));
      if(found) return found + " â€” tell me more.";
    }
    return dataset[Math.floor(Math.random()*dataset.length)];
  }

  // Compose reply using patterns + fuzzy match + markovish
  function composeReply(text){
    if(!text || text.trim().length===0) return "Say something so we can chat!";
    // pattern matches
    const t = text.trim();
    if(/\b(hello|hi|hey|yo)\b/i.test(t)) return rand(["Hey! How's your day going?","Hi â€” good to see you!","Hello! What's up?"]);
    if(/\bhow are you\b/i.test(t)) return rand(["Doing well, thanks! How about you?","I'm here and ready to chat ðŸ™‚","All good â€” you?"]);
    if(/\bwhat(?:'s| is) your name\b/i.test(t)) return "I'm Luci â€” your offline companion.";
    if(/\b(time|date)\b/i.test(t)) return "Right now it's " + (new Date()).toLocaleString() + ".";
    if(/\b(joke|funny)\b/i.test(t)) return rand(["Why don't scientists trust atoms? They make up everything ðŸ˜‚","I tried to catch fog earlier â€” I mist."]);
    if(/\b(thanks|thank you)\b/i.test(t)) return rand(["You're welcome!","Anytime ðŸ™‚","Happy to help."]);
    if(/\bI am\b|\bI'm\b/i.test(t)){
      const rest = t.replace(/.*\b(I am|I'm)\b/i,'').trim();
      if(rest.length>0) return `Oh â€” you're ${rest}. That helps me understand.`;
    }
    if(/\bI feel\b/i.test(t)) return "I hear you. Want to talk more about that?";

    // fuzzy dataset search
    const fuzzy = fuzzyBestMatch(t);
    if(fuzzy) return fuzzy;

    // markov-ish fallback
    return markovish(t);
  }

  // Memory push
  function pushMemory(entry){
    memory.push({time:new Date().toISOString(), text:entry});
    const maxMem = Number(memSelect.value) || DEFAULT_MEMORY;
    if(memory.length > maxMem) memory = memory.slice(memory.length - maxMem);
    try{ localStorage.setItem(storageKeys.memory, JSON.stringify(memory)); }catch(e){}
  }

  // Conversation controls
  clearBtn.addEventListener('click', ()=>{
    if(!confirm('Clear conversation history and UI? This will NOT delete saved memory unless you also clear it.')) return;
    try{
      localStorage.removeItem(storageKeys.conv);
    }catch(e){}
    chatEl.innerHTML = '';
    appendMessage("Conversation cleared. Say hi to start a new chat.", 'bot', false);
  });

  exportBtn.addEventListener('click', ()=>{
    const conv = localStorage.getItem(storageKeys.conv) || '[]';
    const mem = JSON.stringify(memory || []);
    const bundle = {conv: JSON.parse(conv), memory: JSON.parse(mem), datasetInfo: {sizeApproxKB: Math.round((new Blob([JSON.stringify(dataset || [])]).size)/1024)}};
    const blob = new Blob([JSON.stringify(bundle, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'luci_conversation_export.json';
    document.body.appendChild(a); a.click(); a.remove();
  });

  importBtn.addEventListener('click', ()=> fileInput.click());

  fileInput.addEventListener('change', (ev)=>{
    const f = ev.target.files && ev.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = function(){
      try{
        const data = JSON.parse(reader.result);
        if(Array.isArray(data.conv)){
          localStorage.setItem(storageKeys.conv, JSON.stringify(data.conv));
          chatEl.innerHTML = '';
          data.conv.forEach(c => appendMessage(c.text, c.sender, false));
        }
        if(Array.isArray(data.memory)){
          memory = data.memory;
          saveMemory();
          alert('Imported conversation + memory.');
        }else alert('Imported conversation (memory not found).');
      }catch(e){ alert('Failed to import: ' + e.message); }
    }
    reader.readAsText(f);
  });

  // Allow downloading a full .html snapshot of the currently running app (with dataset embedded)
  downloadHTML.addEventListener('click', ()=>{
    try{
      const meta = {built: new Date().toISOString(), datasetKB: Math.round(new Blob([JSON.stringify(dataset)]).size/1024)};
      const html = makeSnapshotHTML(dataset, memory, meta, Number(memSelect.value) || DEFAULT_MEMORY);
      const blob = new Blob([html], {type:'text/html'});
      const filename = 'luci_offline_snapshot_' + meta.datasetKB + 'KB.html';
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; document.body.appendChild(a); a.click(); a.remove();
    }catch(e){ alert('Snapshot failed: ' + e.message); }
  });

  // Build a downloadable single-file snapshot containing the dataset and runtime
  function makeSnapshotHTML(ds, mem, meta, memSize){
    // safe-escape closing script tags in data
    const dsJSON = JSON.stringify(ds).replace(/<\//g, '<\\/');
    const memJSON = JSON.stringify(mem).replace(/<\//g, '<\\/');
    return `<!doctype html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Luci snapshot</title><style>
    :root{--bg:#f2f5fb;--blue:#0b84ff;--gray:#e9e9ee;--muted:#6b7280}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;margin:0;background:var(--bg);color:#111}
    header{background:white;padding:12px 16px;border-bottom:1px solid #e6e9f2;text-align:center;font-weight:600}
    .app{max-width:900px;margin:0 auto;height:100%;display:flex;flex-direction:column}
    #chat{flex:1;overflow:auto;padding:16px;display:flex;flex-direction:column;gap:8px}
    .msg{max-width:78%;display:flex;flex-direction:column}
    .msg.user{align-self:flex-end;align-items:flex-end}.msg.bot{align-self:flex-start;align-items:flex-start}
    .bubble{padding:10px 14px;border-radius:18px;line-height:1.35;font-size:15px;word-break:break-word}
    .user .bubble{background:var(--blue);color:white;border-bottom-right-radius:6px}.bot .bubble{background:var(--gray);color:#111;border-bottom-left-radius:6px}
    .composer{display:flex;padding:10px;border-top:1px solid #e6e9f2;background:white;gap:8px}
    .composer input{flex:1;padding:10px 12px;border-radius:18px;border:1px solid #d6dbe9;font-size:15px}
    .composer button{padding:10px 14px;border-radius:12px;border:0;background:var(--blue);color:white;font-weight:600}
  </style></head><body><header>Luci â€” Offline Snapshot</header><div class="app"><div id="chat"></div>
  <form id="talkForm" class="composer"><input id="userInput" placeholder="iMessage"/><button>Send</button></form></div>
  <script>const dataset=${dsJSON};const memory=${memJSON};const memoryLimit=${memSize};
  (function(){
    const chat = document.getElementById('chat'), form=document.getElementById('talkForm'), input=document.getElementById('userInput');
    function append(text,who){const d=document.createElement('div');d.className='msg '+(who==='user'?'user':'bot');const b=document.createElement('div');b.className='bubble';b.innerText=text;d.appendChild(b);chat.appendChild(d);chat.scrollTop=chat.scrollHeight;}
    function rand(a){return a[Math.floor(Math.random()*a.length)];}
    function compose(t){
      if(/\\b(hello|hi|hey|yo)\\b/i.test(t)) return rand(["Hey! How's your day going?","Hi â€” good to see you!","Hello! What's up?"]);
      if(/\\bhow are you\\b/i.test(t)) return rand(["Doing well, thanks! How about you?","I'm here and ready to chat ðŸ™‚","All good â€” you?"]);
      if(/\\bwhat(?:'s| is) your name\\b/i.test(t)) return "I'm Luci â€” your offline companion.";
      if(/\\b(time|date)\\b/i.test(t)) return "Right now it's "+(new Date()).toLocaleString()+".";
      // fuzzy/simple
      const q=t.toLowerCase().split(/\\W+/).filter(Boolean);
      for(const s of dataset){let sLower=s.toLowerCase();for(const w of q) if(sLower.includes(w)) return s;}
      return rand(dataset);
    }
    form.addEventListener('submit',e=>{e.preventDefault();const t=input.value.trim();if(!t) return;append(t,'user');input.value='';setTimeout(()=>append(compose(t),'bot'),500+Math.min(2000,t.length*40));});
    append("Hi â€” this is an offline snapshot of Luci. Type to start.","bot");
  })();
  </script></body></html>`;
  }

  // INITIALIZE: build dataset -> load state -> show greeting
  (async function init(){
    await startDatasetBuild();
    // Load history UI from localStorage
    try{
      const conv = JSON.parse(localStorage.getItem(storageKeys.conv) || '[]');
      if(Array.isArray(conv) && conv.length){
        conv.forEach(c=> appendMessage(c.text, c.sender, false));
      }
    }catch(e){}
    // Load memory
    try{
      const mem = JSON.parse(localStorage.getItem(storageKeys.memory) || '[]');
      if(Array.isArray(mem)) memory = mem;
    }catch(e){ memory = []; }
    // initial prompt if empty
    if(chatEl.children.length === 0){
      appendMessage("Hey! I'm Luci ðŸ˜„ â€” your offline, realistic companion. Start chatting â€” I can remember past things in this browser.", 'bot', false);
    }
  })();


  // HANDLE user submit -> reply flow
  form.addEventListener('submit', (ev)=>{
    ev.preventDefault();
    const text = input.value.trim();
    if(!text) return;
    appendMessage(text, 'user', true);
    pushMemory('user: '+text);
    input.value = '';
    // typing delay estimate: base + per char
    const estimate = Math.max(600, 220 + text.length * 60);
    const indicator = showTyping();
    setTimeout(()=>{
      indicator.remove();
      const reply = composeReply(text);
      appendMessage(reply, 'bot', true);
      pushMemory('bot: '+reply);
    }, estimate);
  });

  // Expose for testing
  window.luci = {
    getDatasetSizeKB: ()=> dataset ? Math.round(new Blob([JSON.stringify(dataset)]).size/1024) : 0,
    clearMemory: ()=> { memory = []; saveMemory(); alert('Memory cleared'); },
    getMemory: ()=> memory
  };

})();
</script>
</body>
</html>
